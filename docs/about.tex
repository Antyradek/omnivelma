\chapter{Opis problemu}
\section{Cel}
Celami tej pracy inżynierskiej są budowa modelu podstawy jezdnej, zaprogramowanie go i symulacja w środowisku komputerowym.
W ten sposób powstanie wirtualna kopia prawdziwej podstawy, aby dało się bezproblemowo zaprogramować i przetestować do niej zewnętrzny program sterujący.
Testowanie programu na prawdziwym obiekcie może prowadzić do jego uszkodzeń w czasie testów, a także nie pozwala na przeprowadzanie dowolnego scenariusza i ustawień środowiska testowego, 
co jest łatwiejsze do przeprowadzenia wirtualnie.

Po stworzeniu odpowiedniego modelu i programu sterującego, można w łatwy sposób zamienić model na rzeczywistego robota z zachowaniem tego samego programu i ustawień.

\section{Podstawa jezdna}
Jest to duża podstawa dookólna jeżdżąca na czterech kołach szwedzkich (Mecanum).
Są to specjalne koła z dodatkowymi rolkami ustawionymi pod kątem $45^\circ$ pozwalające na ruch platformy w dowolnym kierunku niezależnie od kąta obrotu robota.
Za ich pomocą da się także obracać całością w czasie jazdy.

Koła są stałe, obracają się tylko w jednej osi.
Każde koło jest sterowane osobno przez serwomotor.
Każdy z serwomotorów ma także wbudowany enkoder do sprawdzania rzeczywistego kąta obrotu.

Podstawa ma za zadanie wozić wydziałowego robota manipulującego Velma.
Duża masa i wysokość konstrukcji powoduje, że sama podstawa potrzebuje mieć sporą nośność i szerokość, aby się nie przewrócić.
Jeżdżąc na tej podstawie robot może się przemieszczać i obracać w dowolnym kierunku, aby uzyskać lepszy dostęp do manipulowanych przedmiotów.

Z jednej strony platformy znajduje się zawias pozwalający na niezależny obrót osi względem siebie.
Ma to za zadanie zapewnić, aby każde koło dociskało do podłoża z taką samą siłą, jak to po drugiej stronie osi.
Pozwala to także na pokonywanie drobnych nierówności terenu.
Bez tego zawiasu nierówna podłoga spowodowała by, że na przykład tylko trzy koła dotykałyby podłoża w danym momencie uniemożliwiając sprawne sterowanie.

\section{Składniki systemu}
Symulacja składa się z kilku odrębnych składników, które komunikują się ze sobą poprzez specjalne interfejsy oparte o kolejki wiadomości.
To pozwala wymieniać elementy zachowując tę samą komunikację między sobą.

Na składniki systemu składają się:
\begin{description}
 \item[Model] Odpowiednio opisany równaniami ma być jak najdokładniejszą kopią fizycznego robota.
 Musi brać pod uwagę masy i momenty bezwładności elementów składowych, a także możliwe tarcia.
 Model posiada także więzy na ruchome elementy, jak koła i rolki.
 
 Dla ozdoby można mu nadać wygląd zbliżony do prawdziwego robota poprzez wymodelowanie siatki w programie graficznym.
 
 \item[Sterownik silników] Ma taką samą funkcjonalność, jak pokładowy sterownik niskopoziomowy na robocie.
 Zadaniem pokładowego sterownika jest przyjęcie wartości sterowania od zewnętrznego programu i podanie odpowiednich wartości napięcia na silniki kół.
 Może także wprowadzać niezależne zabezpieczenia przed zniszczeniem urządzenia przez nieprawidłowe sterowanie.
 Dobrze jest, jeśli program działa w czasie rzeczywistym na mikrokontrolerze.
 Taki program jest najczęściej dostarczony przez producenta robota.
 
 Symulacja polega na stworzeniu alternatywnego programu pobierającego podobne do fizycznej wersji dane i obracającego kołami w odpowiedni sposób.
 Silnik fizyczny symulatora przekłada ten ruch na odpowiednie prędkości w przestrzeni wirtualnej.
 
 \item[Sterownik czujników] Normalny sterownik pobiera surowe dane i zamienia je na format możliwy do odczytania przez program.
 Najczęściej polega to na próbkowaniu sygnału i wysyłaniu go dalej.
 Ten program może także robić wstępne obrabianie danych w celach usuwania szumów, korekcji błędów stałych, albo szybkiej obróbki na wyższy format, jak ma to miejsce choćby w Kinectcie.
 
 Symulując ten element budujemy program generujący dane na podstawie symulacji. 
 W celu przybliżenia go do realizmu można także dodawać do generowanych danych sztuczny szum i błędy, aby łatwiej można było go zamienić później na prawdziwy czujnik.
 
 \item[Program sterujący] Cześć odpowiedzialna za logikę aplikacji. Tutaj podejmowane są decyzje, jakie wymusić prędkości kół, aby pojechać po wymaganej krzywej.
 Ten program także pobiera, obrabia i interpretuje surowe dane z czujników.
 
 W tej części używanych jest wiele algorytmów, jak budowa mapy, szukanie ścieżki, unikanie kolizji, wyznaczanie obiektów na obrazie itp.
 Zwykle działa to na dużych, wielowątkowych maszynach ze względu na spore wymagania algorytmów.

\end{description}

\section{Użyte technologie}

% technologie - Czemu Gazebo, V-rep i ROS
% Gazebo przydatnie, otwarty opis robota, natywny ROS, C++ i czysty kod
% V-Rep dziwny opis, nietypowe i skomplikowane funkacje w czytym C, Lua?, słaby silnik


% uruchomienie - Czemu Ubuntu i co w Ubuntu

% sposób modelowania (w edytorze tekstowym)

% sposób pisania oprogramowania

% Wymagania oprogramowania na niezawodność

% istniejące implemetacje (Yuka w Gazebo, co jest tylko modelem)
% Youbot kuka w V-Rep, która działa w pełni
